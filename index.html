<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Block Blast - Mobile & High Score</title>
<style>
body {margin:0;padding:0;font-family:sans-serif;background:#f0f0f0;display:flex;flex-direction:column;align-items:center;}
h1{margin:20px;}
canvas{background:#fff;margin-top:10px;border:2px solid #333;touch-action:none;}
#score,#highscore{font-size:20px;margin-top:10px;}
#gameover{display:none;font-size:24px;color:red;margin-top:20px;}
</style>
</head>
<body>
<h1>Block Blast - Mobile & High Score</h1>
<div id="score">ƒêi·ªÉm: 0</div>
<div id="highscore">K·ª∑ l·ª•c: 0</div>
<div id="gameover">GAME OVER!</div>
<canvas id="game" width="500" height="550"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const gridSize = 9;
const cellSize = 50;
let grid = [], score = 0, gameOver = false;
let highScore = localStorage.getItem('blockBlastHigh') || 0;

// Kh·ªüi t·∫°o grid
for(let r=0;r<gridSize;r++){
  grid[r]=[];
  for(let c=0;c<gridSize;c++) grid[r][c]=0;
}

// M√†u block
const colors = ['#ff4d4d','#4dff4d','#4db8ff','#ffe64d','#ff99ff','#ff9933'];

// Block types
const blockTypes = [
[[1]], // 1x1
[[1,1]], // 1x2
[[1],[1]], //2x1
[[1,1],[1,1]], //2x2
[[1,1,1],[0,1,0]], //T
[[1,1,0],[0,1,1]], //Z
[[1,0],[1,1]] //L
];

let currentBlocks = [], dragBlock = null, offsetX=0, offsetY=0;
let effects = [];

// T·∫°o 3 block m·ªõi
function generateBlocks(){
  currentBlocks=[];
  for(let i=0;i<3;i++){
    const type = JSON.parse(JSON.stringify(blockTypes[Math.floor(Math.random()*blockTypes.length)]));
    const color = colors[Math.floor(Math.random()*colors.length)];
    currentBlocks.push({shape:type,color:x=color,x:10+i*150,y:460});
  }
  draw();
}

// V·∫Ω grid + blocks + hi·ªáu ·ª©ng
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // grid
  for(let r=0;r<gridSize;r++){
    for(let c=0;c<gridSize;c++){
      ctx.fillStyle = grid[r][c]||'#fff';
      ctx.fillRect(c*cellSize,r*cellSize,cellSize,cellSize);
      ctx.strokeStyle='#ccc';
      ctx.strokeRect(c*cellSize,r*cellSize,cellSize,cellSize);
    }
  }
  // blocks
  currentBlocks.forEach(b=>{
    for(let i=0;i<b.shape.length;i++){
      for(let j=0;j<b.shape[0].length;j++){
        if(b.shape[i][j]===1){
          ctx.fillStyle=b.color;
          ctx.fillRect(b.x+j*cellSize,b.y+i*cellSize,cellSize,cellSize);
          ctx.strokeStyle='#333';
          ctx.strokeRect(b.x+j*cellSize,b.y+i*cellSize,cellSize,cellSize);
        }
      }
    }
  });
  // hi·ªáu ·ª©ng ƒÉn ƒëi·ªÉm
  effects.forEach((e,i)=>{
    ctx.fillStyle=e.color;
    ctx.globalAlpha=e.alpha;
    ctx.beginPath();
    ctx.arc(e.x,e.y,e.size,0,2*Math.PI);
    ctx.fill();
    ctx.globalAlpha=1;
    e.y -= 1; e.alpha -= 0.02; e.size += 0.3;
    if(e.alpha<=0) effects.splice(i,1);
  });
  document.getElementById('score').innerText='ƒêi·ªÉm: '+score;
  document.getElementById('highscore').innerText='K·ª∑ l·ª•c: '+highScore;
  if(!gameOver) requestAnimationFrame(draw);
}

// L·∫•y v·ªã tr√≠ chu·ªôt/touch
function getMousePos(evt){
  const rect = canvas.getBoundingClientRect();
  return {x:evt.clientX-rect.left||evt.pageX-rect.left, y:evt.clientY-rect.top||evt.pageY-rect.top};
}

// K√©o th·∫£ chu·ªôt
canvas.addEventListener('mousedown', e=>{
  if(gameOver) return;
  const pos = getMousePos(e);
  currentBlocks.forEach(b=>{
    for(let i=0;i<b.shape.length;i++){
      for(let j=0;j<b.shape[0].length;j++){
        if(b.shape[i][j]===1){
          const bx = b.x+j*cellSize;
          const by = b.y+i*cellSize;
          if(pos.x>=bx && pos.x<=bx+cellSize && pos.y>=by && pos.y<=by+cellSize){
            dragBlock = b;
            offsetX = pos.x-b.x;
            offsetY = pos.y-b.y;
          }
        }
      }
    }
  });
});
canvas.addEventListener('mousemove', e=>{
  if(dragBlock){
    const pos = getMousePos(e);
    dragBlock.x = pos.x - offsetX;
    dragBlock.y = pos.y - offsetY;
  }
});
canvas.addEventListener('mouseup', e=>{
  if(dragBlock){
    const r = Math.round(dragBlock.y/cellSize);
    const c = Math.round(dragBlock.x/cellSize);
    if(canPlace(r,c,dragBlock.shape)){
      placeBlock(r,c,dragBlock);
      checkLines();
      if(checkGameOver()) endGame();
    }
    dragBlock = null;
  }
});

// K√©o th·∫£ c·∫£m ·ª©ng ƒëi·ªán tho·∫°i
canvas.addEventListener('touchstart', e=>{
  e.preventDefault();
  if(gameOver) return;
  const touch = e.touches[0];
  const pos = getMousePos(touch);
  currentBlocks.forEach(b=>{
    for(let i=0;i<b.shape.length;i++){
      for(let j=0;j<b.shape[0].length;j++){
        if(b.shape[i][j]===1){
          const bx = b.x+j*cellSize;
          const by = b.y+i*cellSize;
          if(pos.x>=bx && pos.x<=bx+cellSize && pos.y>=by && pos.y<=by+cellSize){
            dragBlock = b;
            offsetX = pos.x-b.x;
            offsetY = pos.y-b.y;
          }
        }
      }
    }
  });
});
canvas.addEventListener('touchmove', e=>{
  e.preventDefault();
  if(dragBlock){
    const touch = e.touches[0];
    const pos = getMousePos(touch);
    dragBlock.x = pos.x - offsetX;
    dragBlock.y = pos.y - offsetY;
  }
});
canvas.addEventListener('touchend', e=>{
  e.preventDefault();
  if(dragBlock){
    const r = Math.round(dragBlock.y/cellSize);
    const c = Math.round(dragBlock.x/cellSize);
    if(canPlace(r,c,dragBlock.shape)){
      placeBlock(r,c,dragBlock);
      checkLines();
      if(checkGameOver()) endGame();
    }
    dragBlock = null;
  }
});

// Ki·ªÉm tra ƒë·∫∑t block
function canPlace(r,c,shape){
  for(let i=0;i<shape.length;i++){
    for(let j=0;j<shape[0].length;j++){
      if(shape[i][j]===1){
        const rr=r+i,cc=c+j;
        if(rr<0||rr>=gridSize||cc<0||cc>=gridSize||grid[rr][cc]!==0) return false;
      }
    }
  }
  return true;
}

function placeBlock(r,c,block){
  for(let i=0;i<block.shape.length;i++){
    for(let j=0;j<block.shape[0].length;j++){
      if(block.shape[i][j]===1){
        grid[r+i][c+j]=block.color;
      }
    }
  }
  currentBlocks=currentBlocks.filter(b=>b!==block);
  if(currentBlocks.length===0) generateBlocks();
}

// X√≥a h√†ng/c·ªôt + hi·ªáu ·ª©ng ƒÉn ƒëi·ªÉm
function checkLines(){
  let cleared=0;
  // rows
  for(let r=0;r<gridSize;r++){
    if(grid[r].every(v=>v!==0)){
      cleared++;
      for(let c=0;c<gridSize;c++){
        spawnEffect(c*cellSize+cellSize/2,r*cellSize+cellSize/2,grid[r][c]);
        grid[r][c]=0;
      }
    }
  }
  // cols
  for(let c=0;c<gridSize;c++){
    let full=true;
    for(let r=0;r<gridSize;r++) if(grid[r][c]===0) full=false;
    if(full){
      cleared++;
      for(let r=0;r<gridSize;r++){
        spawnEffect(c*cellSize+cellSize/2,r*cellSize+cellSize/2,grid[r][c]);
        grid[r][c]=0;
      }
    }
  }
  if(cleared>0) score += cleared*10;
}

// Hi·ªáu ·ª©ng ƒÉn ƒëi·ªÉm
function spawnEffect(x,y,color){
  for(let i=0;i<10;i++){
    effects.push({x:x,y:y,color:color||colors[Math.floor(Math.random()*colors.length)],size:5,alpha:1});
  }
}

// Game over
function checkGameOver(){
  for(let b of currentBlocks){
    for(let r=0;r<gridSize;r++){
      for(let c=0;c<gridSize;c++){
        if(canPlace(r,c,b.shape)) return false;
      }
    }
  }
  return true;
}
function endGame(){
  gameOver=true;
  document.getElementById('gameover').style.display='block';
  if(score>highScore){
    highScore = score;
    localStorage.setItem('blockBlastHigh',highScore);
    alert('üéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ l·∫≠p k·ª∑ l·ª•c m·ªõi: '+highScore);
  }
}

generateBlocks();
draw();
</script>
</body>
</html>